from algorithms import BaseAlgorithm
from algorithms import getNumNetworkParams, overwriteNetworkParams
import torch, numpy as np
import policies
import korali

class CMAESKorali(BaseAlgorithm):
    """CMA-ES-based training algorithm using Korali."""
    def __init__(self, policy, populationSize=32, sigma=0.1):
        self.populationSize = populationSize
        self.sigma = sigma

    def trainPolicy(self, policy, env, numIterations):
        """Evaluate `numIterations` updating iterations on the given policy for
        the given environment."""
        returns = np.zeros([numIterations * self.populationSize])
        # Define the objective.
        i = 0
        def objective(p):
            """Update the policy with given parameters, evalute and return the reward."""
            weights = p["Parameters"]
            overwriteNetworkParams(policy.layers, weights)

            meanReward = 0
            for ep in range(env.numEpisodesPerEvaluation):  # Each new episode starts here.
                states, actions, policyEvaluations, rewards = env.performOneEpisode(policy)
                meanReward += sum(rewards)
            meanReward /= env.numEpisodesPerEvaluation

            p["Evaluation"] = meanReward
            returns[i] = meanReward
            i += 1
        # Create Korali and problem objects.
        k = korali.Engine()
        e = korali.Experiment()

        # Configure the problem.
        e["Problem"]["Type"] = "Direct/Basic"  # Use Korali v1.0.1.
        e["Problem"]["Objective Function"] = objective

        # Define the problem variables.
        numParams = getNumNetworkParams(policy.layers);
        print("Number of policy parameters =", numParams)
        for i in range(numParams):
            e["Variables"][i]["Name"] = "X" + str(i)
            # Initial distribution of population samples.
            e["Variables"][i]["Initial Mean"] = 0.0
            e["Variables"][i]["Initial Standard Deviation"] = self.sigma
            # Bounds are necessary to avoid pathological cases generated by Gaussians.
            e["Variables"][i]["Lower Bound"]  = -100.0
            e["Variables"][i]["Upper Bound"]  = +100.0

        # Configure CMA-ES parameters.
        e["Solver"]["Type"] = "Optimizer/CMAES"
        e["Solver"]["Population Size"] = self.populationSize
        # e["Solver"]["Termination Criteria"]["Min Value Difference Threshold"] = 1e-7
        e["Solver"]["Termination Criteria"]["Max Generations"] = numIterations

        # Run Korali.
        k.run(e)

        maxR = np.max(returns.reshape(numIterations, self.populationSize), axis=1)
        file_object = open('CMAES.txt', 'a')
        for i in range(numIterations): file_object.write('%e ' % maxR[i])
        file_object.write('\n')
        file_object.close()